\documentclass[a4paper,10pt,bibtotoc,abstracton,oneside,noindent,DIV15]{scrartcl}
\usepackage{listings,url}
\usepackage{pslatex,color}
\usepackage[OT1]{fontenc}

\definecolor{lightlightgray}{gray}{0.9}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}

%\usepackage{tex4ht}
\newcommand{\Css}[1]{}

\begin{document}

\lstset{
language=C,                             % Code langugage
basicstyle=\ttfamily,                   % Code font, Examples: \footnotesize, \ttfamily
keywordstyle=\color{OliveGreen},        % Keywords font ('*' = uppercase)
commentstyle=\color{gray},              % Comments font
%numbers=left,                           % Line nums position
%numberstyle=\tiny,                      % Line-numbers fonts
%stepnumber=1,                           % Step between two line-numbers
%numbersep=5pt,                          % How far are line-numbers from code
backgroundcolor=\color{lightlightgray}, % Choose background color
frame=none,                             % A frame around the code
tabsize=2,                              % Default tab size
captionpos=b,                           % Caption-position = bottom
breaklines=true,                        % Automatic line breaking?
breakatwhitespace=false,                % Automatic breaks only at whitespace?
showspaces=false,                       % Dont make spaces visible
showtabs=false,                         % Dont make tabls visible
columns=flexible,                       % Column format
morekeywords={__global__, __device__},  % CUDA specific keywords
}


\lstset{breaklines=true}

\Css{div.lstlisting{font-family: monospace;
    white-space: nowrap; margin-top:0.5em;
    margin-bottom:0.5em;
    color: blue;}}

\Css{ol li { padding: 0; margin: 0.5em; }}

\section{Example applications}

\subsection{Operations on BAM files:}

All examples assume that an input BAM file is initially imported to HDFS via
\begin{lstlisting} 
prepareBamInput.sh input.bam
\end{lstlisting} 
and then loaded in the grunt shell via
\begin{lstlisting} 
grunt> A = load 'input.bam' using BamUDFLoader('yes');
\end{lstlisting} 
(the 'yes' chooses read attributes to be loaded; choose 'no' whenever these
are not required).

Once some operations have been performed, the resulting (modified) read
data can then be stored into a new BAM file via
\begin{lstlisting}
grunt> store A into 'output.bam' using BamUDFStorer('input.bam.asciiheader');
\end{lstlisting}
and can also be exported from HDFS to the local filesystem via
\begin{lstlisting}
prepareBamOutput.sh output.bam
\end{lstlisting}
(note: the Pig store operation requires a valid header for the BAM output file,
for example the header of the source file used to generate it, which is
generated automatically by the prepareBamInput.sh script used to import it)

Note that dumping the BAM data to the screen (similarly to samtools view)
can be done simply by
\begin{lstlisting}
grunt> dump A;
\end{lstlisting}
Another very useful Pig command is describe, which returns the schema that Pig
uses for a given data bag. Example:
\begin{lstlisting}
grunt> describe A;
\end{lstlisting}
which returns for BAM data
\begin{lstlisting}  
  A: {name: chararray,start: int,end: int,read: chararray,cigar: chararray,
   basequal: chararray,flags: int,insertsize: int,mapqual:int,matestart: int,
   materefindex: int,refindex: int,refname: chararray,attributes: map[]}
\end{lstlisting}
Note that all fields except the attributes are standard data types (strings
or integers). Specific attributes can be accessed via attributes\#'name', for
example
\begin{lstlisting} 
grunt> B = FOREACH A GENERATE name, attributes#'MD';
grunt> dump B;
\end{lstlisting}
will output all read names and their corresponding MD tag.
Other useful commands are LIMIT and SAMPLE, which can be used for example for obtaining
a subset of reads from a BAM/SAM file which can be useful for debugging.
\begin{lstlisting} 
grunt> B = LIMIT A 20;
\end{lstlisting}
will assign the first 20 records of A to B, while
\begin{lstlisting}
grunt> B = SAMPLE A 0.01;
\end{lstlisting}
will sample from A with sampling probability 0.01.

\subsubsection{Filtering out unmapped reads and PCR or optical duplicates}
\begin{lstlisting}
grunt> A = FILTER A BY (flags/4)%2==0 and (flags/1024)%2==0;
\end{lstlisting}

\subsubsection{Filtering out reads with low mapping quality}
\begin{lstlisting}
grunt> A = FILTER A BY mapqual > 19;
\end{lstlisting}
 \subsubsection{Filtering by regions (samtools syntax)}
\begin{lstlisting}
 grunt> DEFINE myFilter CoordinateFilter('input.bam.asciiheader','20:0-44350673');
 grunt> B = FILTER A BY myFilter(refindex,start,end);
\end{lstlisting}
Note that filtering by regions requires a valid ascii header for mapping
sequence names to sequence indices.

 \subsubsection{Sorting BAM files}
Sorting an input bam file by chromosome, reference start coordinate, strand
and readname (in this hierarchical order):
\begin{lstlisting}
grunt> A = FOREACH A GENERATE name, start, end, read, cigar, basequal, flags, insertsize,
mapqual, matestart, materefindex, refindex, refname, attributes, (flags/16)%2;
grunt> A = ORDER A BY refname, start, \$14, name;
\end{lstlisting}
NOTE: this is roughly equivalent to executing from the command line:
\begin{lstlisting}
pig -param inputfile=input.bam -param outputfile=input_sorted.bam \${SEQPIG_HOME}/scripts/sort_bam.pig
\end{lstlisting}

 \subsubsection{Computing read coverage}
Computing read coverage over reference-coordinate bins of a fixed size,
for example:
\begin{lstlisting}
grunt> B = GROUP A BY start/200;
grunt> C = FOREACH B GENERATE group, COUNT(A);
grunt> dump C; 
\end{lstlisting}
will output the number of reads that lie in any non-overlapping bin of size 200 base pairs.

 \subsubsection{Computing base frequencies (counts) for each reference coordinate}
\begin{lstlisting}
grunt> A = FOREACH A GENERATE read, flags, refname, start, cigar, mapqual;
grunt> A = FILTER A BY (flags/4)%2==0;
grunt> RefPos = FOREACH A GENERATE ReadRefPositions(read, flags, refname, start, cigar, basequal), mapqual;
grunt> flatset = FOREACH RefPos GENERATE flatten(\$0), mapqual;
grunt> grouped = GROUP flatset BY (\$0, \$1, \$2);
grunt> base_counts = FOREACH grouped GENERATE group.chr, group.pos, group.base, COUNT(flatset);
grunt> base_counts = ORDER base_counts BY chr,pos;
grunt> store base_counts into 'input.basecounts';
\end{lstlisting}
NOTE: this is roughly equivalent to executing from the command line:
\begin{lstlisting}
pig -param inputfile=input.bam -param outputfile=input.basecounts -param pparallel=1 \${SEQPIG_HOME}/scripts/basefreq.pig 
\end{lstlisting}

\subsubsection{Pileup}
Generating samtools compatible pileup (for a correctly sorted BAM file
with MD tags aligned to the same reference, should produce the same output as
samtools mpileup -A -f ref.fasta -B input.bam):
\begin{lstlisting}
grunt> A = load 'input.bam' using BamUDFLoader('yes');
grunt> B = FILTER A BY (flags/4)%2==0 and (flags/1024)%2==0;
grunt> C = FOREACH B GENERATE ReadPileup(read, flags, refname, start, cigar,
      basequal, attributes#'MD', mapqual), start, flags, name;
grunt> C = FILTER C BY \$0 is not null;
grunt> D = FOREACH C GENERATE flatten(\$0), start, flags, name;
grunt> E = GROUP D BY (chr, pos);
grunt> F = FOREACH E { G = FOREACH D GENERATE refbase, pileup, qual, start,
      (flags/16)%2, name; G = ORDER G BY start, \$4, name; GENERATE group.chr,
      group.pos, PileupOutputFormatting(G, group.pos); }
grunt> F = ORDER F BY chr, pos;
grunt> G = FOREACH F GENERATE chr, pos, flatten(\$2);
grunt> store G into 'input.pileup' using PigStorage('\t');
\end{lstlisting}
NOTE: this is equivalent to executing from the command line:
\begin{lstlisting}
pig -param inputfile=input.bam -param outputfile=input.pileup -param pparallel=1 \${SEQPIG_HOME}/scripts/pileup.pig
\end{lstlisting}
There are two optional parameters for pileup.pig: min\_map\_qual and
min\_base\_qual (both with default value 0) that filter out reads with
either insufficient map quality or base qualities. Their values can
be set the same way as the other parameters above.

\subsection{Other supported file formats}

Besides BAM files, seqpig also supports the uncompressed file format SAM for
aligned sequence data. For raw read data seqpig supports both FastQ and Qseq
input and output. Loading and storing data follows along the same lines as
for BAM.

\subsection{Optimizations}

For performance reasons it is typically advisable to enable compression of
Hadoop map (and possible reduce) output, as well as temporary data generated
by Pig. The details depend on which compression codecs are used, but it can
be enabled by passing parameters along the lines of
\begin{lstlisting}
  -Djava.library.path=/opt/hadoopgpl/native/Linux-amd64-64
  -Dpig.tmpfilecompression=true -Dpig.tmpfilecompression.codec=lzo
  -Dmapred.output.compress=true
  -Dmapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec
\end{lstlisting}

 to the pig command. Note that currently not all Hadoop compression codecs are
 supported by Pig.

For more examples see also the wiki of two past COST hackathons:\\
\url{http://seqahead.cs.tu-dortmund.de/meetings:fastqpigscripting}
\url{http://seqahead.cs.tu-dortmund.de/meetings:2012-05-hackathon:pileuptask}
\url{http://seqahead.cs.tu-dortmund.de/meetings:2012-05-hackathon:seqpig_life_savers_page}

\end{document}

